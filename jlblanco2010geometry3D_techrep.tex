\documentclass[a4paper,10pt]{report}
  
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{array}
\usepackage{float}
\usepackage{subfigure}
\usepackage{color}
\usepackage{listings}
\usepackage[utf8x]{inputenc}

\usepackage{amsfonts}  % For \mathbb

\usepackage{fancyhdr}               % Cabeceras
%\usepackage[dvips]{graphicx}
\usepackage{titlesec}
\usepackage{color}
\usepackage{colortbl}
\usepackage{lastpage}
\usepackage{array}
\usepackage{multirow}
\usepackage{datetime}

\input{MAPIR_techrep_template.tex}
  

%% This MUST BE the last include:
\usepackage[ps2pdf,bookmarks=true,breaklinks=true,linkbordercolor={0 0 1}]{hyperref}


% \addtolength{\oddsidemargin}{-.5in}
% \addtolength{\evensidemargin}{-.5in}
% \addtolength{\textwidth}{1.0in}
\addtolength{\topmargin}{-.5in}
% \addtolength{\textheight}{1.0in}


% Title Page
% \title{6D poses as Euler angles, transformation matrices and quaternions: equivalences, compositions and uncertainty}
% \author{Jose-Luis Blanco\\jlblanco@ctima.uma.es\\~\\Technical Report\\~\\
% MAPIR Group\\University of M\'alaga, Spain}


\begin{document}



\definecolor{lightgray}{rgb}{0.93,0.93,0.93}
\definecolor{darkgray}{rgb}{0.5,0.5,0.5}
%%\lstset{frameround=fttt}
\lstset{language=C++}
\lstset{backgroundcolor=\color{lightgray}}
%% \lstset{numbers=left, numberstyle=\tiny, numbersep=5pt} %% stepnumber=2,
\lstset{keywordstyle=\color{blue}\bfseries\emph}
\lstset{commentstyle=\color{darkgray}\emph}
\lstset{basicstyle=\ttfamily\scriptsize} %%\footnotesize}


\title{}
\author{\\\\~\\Technical Report\\~\\
of M\'alaga, Spain}

\TRInfo{Parameterizations of $\mathbf{SE}(3)$ transformations: equivalences, compositions and uncertainty}
{Jose-Luis Blanco\\ \texttt{joseluisblancoc@gmail.com}}
{MAPIR Group}{}{012010}{Date: \ddmmyyyydate \today }
\PageStyle

%\maketitle
\pagestyle{plain}

\begin{abstract}
An arbitrary rigid transformation in $\mathbf{SE}(3)$ can be separated into two parts, namely, 
a translation and a rigid rotation.
This technical report reviews, under a unifying viewpoint, three common alternatives to representing the 
rotation part: sets of three (yaw-pitch-roll) Euler angles, orthogonal rotation matrices from 
$\mathbf{SO}(3)$ and quaternions.
It will be described: 
(i) the equivalence between these representations and the formulas for transforming one to each other
(in all cases considering the translational and rotational parts as a whole),
(ii) how to compose poses in each representation and 
(iii) how the uncertainty of the poses (when modeled as Gaussian distributions)
is affected by these transformations and compositions, 
including subtle details as the need for applying the normalization Jacobians 
when dealing with quaternions.
The text also reflects which MRPT C++ library\footnote{\texttt{http://www.mrpt.org/}} functions implement
each of the described algorithms. 
All the implementations have been thoroughly validated by means of unit testing.
\end{abstract}


\newpage


\textbf{History of document versions:}
\begin{itemize}
 \item Version 1: First version (Released 27/Aug/2010).
\end{itemize}


\newpage

\tableofcontents


%% ================================================
\chapter{Rigid transformations in 3D}


\section{Basic definitions}
\label{sect:basic}

Mathematically, the \emph{special orthogonal} group $\mathbf{SO}(3)$ comprises all possible 
pure (rigid) rotations in $\mathbb{R}^3$ (the Euclidean 3D space). 
The members of this group are $3 \times 3$ orthogonal matrices
which define rotations. Accounting for translations as well leads us 
to the \emph{special Euclidean} 
Lie group $\mathbf{SE}(3)$, the group of all possible linear isometries (``rigid`` transformations)
that $\mathbb{R}^3$ can undergo \cite{eade2008phd,gallier2001geometric}. 

In this report we refer to $\mathbf{SE}(3)$ transformations as \emph{poses}.
A pose can be described by means of a 3D translation plus an orthonormal vector base, 
or coordinate frame, relative to any other arbitrary coordinate reference system. 
The overall number of degrees of freedom is six, hence they can be also referred 
to as \emph{6D poses}.
The Figure~\ref{fig:1} illustrates this definition, where the pose $\mathbf{p}$ is represented
by the axes $\{\mathbf{X}',\mathbf{Y}',\mathbf{Z}' \}$ with respect to a reference frame 
$\{\mathbf{X},\mathbf{Y},\mathbf{Z} \}$.


\begin{figure}[h!]
\centering
\includegraphics[width=0.70\textwidth]{fig_pose_composition.eps}
\caption{Schematic representation of a 6D pose $\mathbf{p}$ and its role in defining 
the relative coordinates $\mathbf{a}'$ of the 3D point $\mathbf{a}$.}
\label{fig:1}
\end{figure}


Given a 6D pose $\mathbf{p}$ and a 3D point $\mathbf{a}$, both relative to some arbitrary
global frame of reference, and being $\mathbf{a}'$ the coordinates of $\mathbf{a}$ relative
to $\mathbf{p}$, we define 
the composition $\oplus$ and inverse composition $\ominus$ operations as follows:

\begin{eqnarray*}
\mathbf{a} & \equiv & \mathbf{p} \oplus \mathbf{a}'   ~~~~~~~ \textrm{Pose composition} \\
\mathbf{a'} & \equiv & \mathbf{a} \ominus \mathbf{p}  ~~~~~~~~ \textrm{Pose inverse composition} \\
\end{eqnarray*}

These operations are intensively applied in a number of robotics and computer vision 
problems, for example, when computing the relative position of a 3D visual landmark 
with respect to a camera while computing the perspective projection of the landmark 
into the image plane.

The composition operators can be also applied to pairs of 6D poses (above we described a combination
of \emph{6D poses} and {3D points}). 
The meaning of composing two poses $\mathbf{p1}$ and $\mathbf{p2}$ 
obtaining a third pose $\mathbf{p} = \mathbf{p1} \oplus \mathbf{p2}$ 
is that of concatenating the transformation of the second pose to the reference system
\emph{already transformed} by the first pose. 
This is illustrated in Figure~\ref{fig:comp_2poses}. 

\begin{figure}
\centering
\subfigure[The pose $\mathbf{p1}$]{\includegraphics[width=0.40\textwidth]{pose_comp_p1.eps}}
\subfigure[The pose $\mathbf{p2}$]{\includegraphics[width=0.40\textwidth]{pose_comp_p2.eps}} \\
\subfigure[Composition $\mathbf{p1} \oplus \mathbf{p2}$]{\includegraphics[width=0.60\textwidth]{pose_comp_p1p2.eps}}

\caption{The composition of two 6D poses $\mathbf{p1}$ and $\mathbf{p2}$ leads to $\mathbf{p}$.}
\label{fig:comp_2poses}
\end{figure}

The inverse pose composition can be also applied to 6D poses, in this case meaning that
the pose $\mathbf{p}$ (in global coordinates) ``is seen'' as $\mathbf{p2}$ with respect
to the reference frame of $\mathbf{p1}$ (this one, also in global coordinates), a 
relationship expressed as $\mathbf{p2} = \mathbf{p} \ominus \mathbf{p1}$.


Up to this point, poses, pose/point and pose/pose compositions have been described 
under a purely geometrical point of view. 
The next section introduces some of the most commonly employed parameterizations.


\newpage

\section{Common parameterizations}


\subsection{3D translation plus yaw-pitch-roll (3D+YPR)}

A 6D pose $\mathbf{p_6}$ can be described as a displacement in 3D plus a rotation defined by 
means of a specific case of Euler angles: yaw ($\phi$), pitch
($\chi$) and roll ($\psi$), that is:

\begin{eqnarray}
\mathbf{p_6} &=& [x ~ y ~ z ~ \phi ~ \chi ~ \psi]^\top
\end{eqnarray}

The geometrical meaning of the angles is represented in Figure~\ref{fig:ypr}. 
There are other alternative conventions about triplets of angles to represent a rotation in 3D, but
the one employed here is the one most commonly used in robotics. 

\begin{figure}[h]
\centering
\includegraphics[width=0.40\textwidth]{fig1.eps}
\caption{A common convention for the angles yaw, pitch and roll.}
\label{fig:ypr}
\end{figure}

Note that the overall rotation is represented as a sequence of three individual rotations, 
each taking a different axis of rotation. 
In particular, the order is: yaw around Z axis, then pitch around the modified Y axis, 
then roll around the modified X axis.

This representation is the most compact since it only requires 6 real parameters
to describe a pose (the minimum number of parameters, since a pose has 6 degrees of freedom).
However, in some applications it may be more advantageous to employ other representations, 
even at the cost of maintaining more parameters.


\subsubsection{Degenerate cases: gimbal lock}
\label{sect:ypr:gimbal}

One of the important disadvantages of the yaw-pitch-roll representation of rotations is the existence 
of two degenerate cases, specifically, when pitch ($\chi$) approaches $\pm 90^\circ$. In this case, 
it is easy to realize that a change in roll becomes a change in yaw.

This means that, for $ \chi = \pm 90^\circ$, there is not a unique correspondence between any possible
rotation in 3D and a triplet of yaw-pitch-roll angles. 
The practical consecuences of this characteristic is the need for detecting and handling these 
special cases, as will be seen in some of the transformations described later on.


\subsubsection{Implementation in MRPT}

Poses based on yaw-pitch-roll angles are implemented in the C++ class \texttt{mrpt::poses::CPose3D}:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3D   p(1.0 /* x */,2.0 /* y */,3.0 /* z */, 
            DEG2RAD(30.0) /* yaw */, DEG2RAD(20.0) /* pitch */, DEG2RAD(90.0) /* roll */ );
\end{lstlisting}


\newpage

\subsection{3D translation plus quaternion (3D+Quat)}

A pose $\mathbf{p_7}$ can be also described with a displacement in 3D plus a rotation 
defined by a quaternion, that is:

\begin{eqnarray}
\mathbf{p_7} &=& [x ~ y ~ z ~  q_r ~ q_x ~ q_y ~ q_z ] ^ \top
\end{eqnarray}

\noindent where the quaternion elements are $[q_r, (q_x,q_y,q_z)]$. A useful interpretation of quaternions
is that of a rotation of $\theta$ radians around the axis defined by the vector $\vec{v} = (v_x,v_y,v_z) \propto (q_x,q_y,q_z)$.
The relation between $\theta$, $\vec{v}$ and the elements in the quaternion is:

\begin{equation*}
\begin{array}{cc}
q_r = \cos\frac{\theta}{2}  &  
  \begin{array}{rcl}
    q_x &=& \sin\frac{\theta}{2} v_x  \\
    q_y &=& \sin\frac{\theta}{2} v_y  \\
    q_z &=& \sin\frac{\theta}{2} v_z  
  \end{array}
\end{array}
\end{equation*}

This interpretation is also represented in Figure~\ref{fig:quat}.

\begin{figure}[h]
\centering
\includegraphics[width=0.50\textwidth]{quaternion.eps}
\caption{A quaternion can be seen as a rotation around an arbitrary 3D axis.}
\label{fig:quat}
\end{figure}


\subsubsection{Implementation in MRPT}

Poses based on quaternions are implemented in the class \texttt{mrpt::poses::CPose3DQuat}. 
The quaternion part of the pose is always normalized (i.e. $q_r^2+q_x^2+q_y^2+q_z^2=1$).

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 
using namespace mrpt::math; 

CPose3DQuat   p(1.0 /* x */,2.0 /* y */,3.0 /* z */, 
                CQuaternionDouble(1.0 /* qr */,  0.0,0.0,0.0 /* vector part */) );
\end{lstlisting}


\subsubsection{Normalization of a quaternion}
\label{sect:quat:norm}

In many situations, the quaternion part of a 3D+Quat 7D representation 
of a pose may drift away of being unitary. 
This is specially true if each component of the quaternion is estimated 
independently, such as within a Kalman filter or 
any other Gauss-Newton iterative optimizer.

The normalization function is simply:

\begin{equation}
\mathbf{q'}(\mathbf{q}) 
= 
\left(
\begin{array}{c}
 q_r' \\ q_x'\\ q_y'\\ q_z'
\end{array}
\right)
= 
\frac{\mathbf{q}}{|\mathbf{q}|} 
= 
\frac{1}{(q_r^2+q_x^2+q_y^2+q_z^2)^{1/2}}
\left(
\begin{array}{c}
 q_r \\ q_x\\ q_y\\ q_z
\end{array}
\right)
\end{equation}

\noindent and its $4 \times 4$ Jacobian is given by:

\begin{equation}
\frac{\partial \mathbf{q'}(q_r,q_x,q_y,q_z)}{\partial q_r,q_x,q_y,q_z}  
=
\frac{1}{(q_r^2+q_x^2+q_y^2+q_z^2)^{3/2}}
\left( 
\begin{array}{cccc}
q_x^2 +q_y^2+q_z^2  & -q_r q_x   & -q_r q_y  & -q_r q_z  \\
-q_x q_r & q_r^2 +q_y^2+q_z^2 & -q_x q_y & - q_x q_z \\
-q_y q_r & -q_y q_x &  q_r^2 +q_x^2 +q_z^2 & -q_y q_z \\
-q_z q_r  & -q_z q_x & -q_z q_y  &  q_r^2+q_x^2+q_y^2
\end{array}
\right)
\end{equation}


%\newpage
%

\subsection{$4 \times 4$ transformation matrices}

Any rigid transformation in 3D can be described by means of a $4 \times 4$ 
matrix $\mathbf{P}$ with the following structure:

\begin{equation}
\mathbf{P}=\left(
  \begin{array}{ccc|c}
   & & & x \\
   & \mathbf{R} & & y \\
   & & & z \\ \hline
   0 & 0 & 0& 1
  \end{array}
\right)
\end{equation}

\noindent where the $3 \times 3$ orthogonal matrix $\mathbf{R} \in \mathbf{SO}(3)$ 
is the \emph{rotation matrix}\footnote{Also called direction cosine matrix (DCM).} 
(the only part of $\mathbf{P}$ related to 
the 3D rotation) and the vector $(x,y,z)$ represents the translational part of the 6D pose. 
For such a matrix to be applicable to 3D points, they must be first represented in 
homogeneous coordinates \cite{bloomenthal1994homogeneous} which, in our case, will consist in just considering a fourth,
extra dimension to each point which will be always equal to the unity -- examples of this will be discussed later on. 


\subsubsection{Implementation in MRPT}

Transformation matrices themselves can be managed as any other normal $4\times 4$ matrix:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::math; 

CMatrixDouble44  P;
\end{lstlisting}

Note however that the 3D+YPR type \texttt{CPose3D} also holds a cached matrix representation 
of the transformation.



%% ================================================

\chapter{Equivalences between representations}

In all the subsequent sections the focus will be on the transformation of the rotational 
part of 6D poses, since the 3D translational part is always a represented as a vector in
all the parameterizations.

Another point to be discussed here is how the transformation between different 
parameterizations affects the \emph{uncertainty} for the case of probability distributions over poses. 
Assuming a multivariate Gaussian model, first order 
linearization of the transforming functions
is proposed as a simple and effective approximation. 
Note that an alternative to this method is using the scaled unscented 
transform (SUT) \cite{julier2002sut}, which may give more exact results for 
large levels of the uncertainty but typically requires more computation time 
and can cause problems for semidefinite positive (in contrast to definite positive) 
covariance matrices.

\section{3D+YPR to 3D+Quat }
\label{sect:ypr2quat}

\subsection{Transformation}

Any given rotation described as a combination of yaw ($\phi$),
pitch ($\chi$) and roll ($\psi$) can
be expressed as a quaternion with components $(q_r, q_x,q_y,q_z)$ 
given by \cite{horn2001some}:

\begin{eqnarray}
  q_r(\phi,\chi,\psi) &=& \cos\frac{\psi}{2} \cos\frac{\chi}{2}  \cos\frac{\phi}{2}  + 
  \sin\frac{\psi}{2} \sin\frac{\chi}{2} \sin\frac{\phi}{2}    \\
  q_x(\phi,\chi,\psi) &=& \sin\frac{\psi}{2} \cos\frac{\chi}{2}  \cos\frac{\phi}{2}  - 
  \cos\frac{\psi}{2} \sin\frac{\chi}{2} \sin\frac{\phi}{2}    \\
  q_y(\phi,\chi,\psi) &=& \cos\frac{\psi}{2} \sin\frac{\chi}{2}  \cos\frac{\phi}{2}  + 
  \sin\frac{\psi}{2} \cos\frac{\chi}{2} \sin\frac{\phi}{2}    \\
  q_z(\phi,\chi,\psi) &=& \cos\frac{\psi}{2} \cos\frac{\chi}{2}  \sin\frac{\phi}{2}  -
  \sin\frac{\psi}{2} \sin\frac{\chi}{2} \cos\frac{\phi}{2}   
\end{eqnarray}


\subsubsection{Implementation in MRPT}

Transformation of a \texttt{CPose3D} pose object based on yaw-pitch-roll angles 
into another of type \texttt{CPose3DQuat} based on quaternions can be done transparently 
due the existence of an implicit conversion constructor:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3D  p6;
...
CPose3DQuat   p7 = p6;  // Transparent conversion
\end{lstlisting}


\subsection{Uncertainty}

Given a Gaussian distribution over a 6D pose in yaw-pitch-roll form with 
mean ${\mathbf{\bar{p}_6}}$ and being  $cov(\mathbf{p_6})$ its $6 \times 6$ covariance matrix, 
the $7 \times 7$ covariance matrix of the equivalent quaternion-based form 
is approximated by:

\begin{equation}
cov(\mathbf{p_7}) =
\frac{\partial \mathbf{p_7}(\mathbf{p_6}) }{\partial \mathbf{p_6}} ~ 
cov(\mathbf{p_6})  ~
\frac{\partial \mathbf{p_7}(\mathbf{p_6}) }{\partial \mathbf{p_6}}^\top 
\end{equation}

\noindent where the Jacobian matrix is given by:

\begin{equation}
\frac{\partial \mathbf{p_7}(\mathbf{p_6}) }{\partial \mathbf{p_6}} =
\left(
\begin{array}{c|cccc}
 \mathbf{I_3} & & \mathbf{0_{3\times 3}} & \\ \hline
  & (ssc-ccs)/2 & (scs-csc)/2 & (css-scc)/2 \\
 \mathbf{0_{4\times 3}}
  & -(csc+scs)/2 & -(ssc+ccs)/2 & (ccc+sss)/2 \\
  & (scc-css)/2 & (ccc-sss)/2 & (ccs-ssc)/2 \\ 
  & (ccc+sss)/2 & -(css+scc)/2 & -(csc+scs)/2 \\ 
\end{array}
\right)_{7 \times 6}
\end{equation}

\noindent where the following abbreviations have been used:

\begin{equation*}
\begin{array}{ccc}
ccc = \cos\frac{\psi}{2}\cos\frac{\chi}{2}\cos\frac{\phi}{2}  & 
ccs = \cos\frac{\psi}{2}\cos\frac{\chi}{2}\sin\frac{\phi}{2}  & 
csc = \cos\frac{\psi}{2}\sin\frac{\chi}{2}\cos\frac{\phi}{2}  \\
 & ... & \\
scc = \sin\frac{\psi}{2}\cos\frac{\chi}{2}\cos\frac{\phi}{2}  & 
ssc = \sin\frac{\psi}{2}\sin\frac{\chi}{2}\cos\frac{\phi}{2}  & 
sss = \sin\frac{\psi}{2}\sin\frac{\chi}{2}\sin\frac{\phi}{2}  \\
\end{array}
\end{equation*}



\subsubsection{Implementation in MRPT}

Gaussian distributions over 6D poses described as yaw-pitch-roll and quaternions 
are implemented in the classes \texttt{CPose3DPDFGaussian} and \texttt{CPose3DQuatPDFGaussian}, respectively.
Transforming between them is possible via an explicit transform constructor, which 
converts both the mean and the covariance matrix:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3DPDFGaussian     p6( p6_mean, p6_cov ); 
...
CPose3DQuatPDFGaussian p7 = CPose3DQuatPDFGaussian(p6);  // Explicit constructor
\end{lstlisting}


%% ------------------
\section{3D+Quat to 3D+YPR  }

\subsection{Transformation}

As mentioned in \S \ref{sect:ypr:gimbal}, the existence of degenerate cases in 
the yaw-pitch-roll representation forces us to consider special cases in many formulas, 
as it happens in this case when a quaternion must be converted into these angles.

Firstly, assuming a normalized quaternion, we define the \emph{discriminant} $\Delta$ as:

\begin{equation}
 \Delta = q_r q_y - q_x q_z
\end{equation}

Then, in most situations we will have $|\Delta|<1/2$, hence we can recover the
yaw ($\phi$),
pitch ($\chi$) and roll ($\psi$) angles as:

\begin{eqnarray}
\left\{
\begin{array}{rcl}
 \phi &=& \tan^{-1} \left( 2 \frac{q_r q_z + q_x q_y}{1-2(q_y^2+q_z^2)}  \right) \nonumber \\
 \chi &=& \sin^{-1} \left( 2 \Delta \right) \label{eq:quat2ypr_1} \\
 \psi &=& \tan^{-1} \left( 2 \frac{q_r q_x + q_y q_z}{1-2(q_x^2+q_y^2)}  \right) \nonumber
\end{array}
\right.
\end{eqnarray}

\noindent which can be obtained from trigonometric identities and 
the transformation matrices associated to a quaternion and a triplet of angles yaw-pitch-roll 
(see \S \ref{sect:ypr2mat}--\ref{sect:quat2mat}).
On the other hand, the special cases when $|\Delta| \approx 1/2$ can be solved as:

\begin{equation}
\begin{array}{c|c}
  \Delta = -1/2 & \Delta = 1/2 \\ \hline
  \begin{array}{rcl}
    \phi &=& 2 \tan^{-1} \frac{q_x}{q_r} \\
    \chi &=& -\pi /2 \\
    \psi &=& 0
  \end{array} 
&
  \begin{array}{rcl}
    \phi &=& -2 \tan^{-1} \frac{q_x}{q_r} \\
    \chi &=& \pi /2 \\
    \psi &=& 0
  \end{array} 
\end{array}
\label{eq:quat2ypr_2}
\end{equation}


\subsubsection{Implementation in MRPT}

Transforming a 6D pose from a quaternion to a yaw-pitch-roll representation is 
achieved transparently via an implicit transform constructor:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3DQuat   p7;
...
CPose3D       p6 = p7;  // Transparent transformation
\end{lstlisting}



\subsection{Uncertainty}

Given a Gaussian distribution over a 7D pose in quaternion form with 
mean ${\mathbf{\bar{p}_7}}$ and being $cov(\mathbf{p_7})$ its $7 \times 7$ covariance matrix, 
we can estimate the $6 \times 6$ covariance matrix of the equivalent yaw-pitch-roll-based 
form by means of:

\begin{equation}
cov(\mathbf{p_6}) =
\frac{\partial \mathbf{p_6}(\mathbf{p_7}) }{\partial \mathbf{p_7}} ~ 
cov(\mathbf{p_7})  ~
\frac{\partial \mathbf{p_6}(\mathbf{p_7}) }{\partial \mathbf{p_7}}^\top 
\end{equation}

\noindent where the Jacobian matrix has the following block structure:

\begin{equation}
\frac{\partial \mathbf{p_6}(\mathbf{p_7}) }{\partial \mathbf{p_7}} =
\left(
\begin{array}{c|c}
 \mathbf{I_3} & \mathbf{0_{3\times 4}} \\ \hline
 \mathbf{0_{3\times 3}} &  \frac{\partial (\phi,\chi,\psi)(q_r,q_x,q_y,q_z)}{\partial q_r,q_x,q_y,q_z}
\end{array}
\right)_{6 \times 7}
\end{equation}

In turn, the bottom-right sub-Jacobian matrix must account for two consecutive transformations: 
normalization of the Jacobian (since each element has an uncertainty, but we need it normalized
for the transformation formulas to hold), then transformation to yaw-pitch-roll form. That is:

\begin{equation}
\frac{\partial (\phi,\chi,\psi)(q_r,q_x,q_y,q_z)}{\partial q_r,q_x,q_y,q_z} =
\frac{\partial (\phi,\chi,\psi)(q_r',q_x',q_y',q_z')}{\partial q_r',q_x',q_y',q_z'}
\frac{\partial (q_r',q_x',q_y',q_z')(q_r,q_x,q_y,q_z)}{\partial q_r,q_x,q_y,q_z}  
\end{equation}

\noindent where the second term in the product is the Jacobian of the quaternion 
normalization (see \S \ref{sect:quat:norm}). Regarding the first term, it is the 
Jacobian of the functions in Eq. \ref{eq:quat2ypr_1}--\ref{eq:quat2ypr_2}, taking
into account that it can take three different forms for the cases $\chi=90^\circ$,
$\chi=-90^\circ$ and $|\chi| \neq 90^\circ$.

\subsubsection{Implementation in MRPT}

This conversion can be achieved by means of an explicit transform constructor, as shown below:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3DQuat            p7_mean = ...
CMatrixDouble77        p7_cov  = ...
CPose3DQuatPDFGaussian p7(p7_mean,p7_cov);
...
CPose3DPDFGaussian     p6 = CPose3DPDFGaussian(p7);  // Explicit constructor
\end{lstlisting}


\section{3D+YPR to matrix }
\label{sect:ypr2mat}

\subsection{Transformation}

The transformation matrix associated to a 6D pose given in yaw-pitch-roll form has this structure:

\begin{equation}
\mathbf{P}(x,y,z,\phi,\chi,\psi)=\left(
  \begin{array}{ccc|c}
   & & & x \\
   & \mathbf{R}(\phi,\chi,\psi) & & y \\
   & & & z \\ \hline
   0 & 0 & 0& 1
  \end{array}
\right)
\label{eq:matP_ypr}
\end{equation}

\noindent where the $3 \times 3$ rotation matrix $\mathbf{R}$ can be easily derived 
from the fact that each of the three individual rotations (yaw, pitch and roll) operate
consecutively one after the other, i.e. over the already modified axis. 
This can be achieved by right-side multiplication of the individual rotation matrices:

\begin{eqnarray}
\mathbf{R}_z(\phi) &=& 
\left(
\begin{array}{ccc}
\cos \phi & -\sin \phi & 0 \\
\sin \phi & \cos \phi & 0 \\
0 & 0 & 1
\end{array}
\right) \quad \mathrm{\text{Yaw rotates around Z}} \\
\mathbf{R}_y(\chi) &= &
\left(
\begin{array}{ccc}
\cos \chi & 0 & \sin \chi \\
0 & 1 & 0 \\
-\sin \chi & 0 & \cos \chi
\end{array}
\right) \quad \mathrm{\text{Pitch rotates around Y}} \\
\mathbf{R}_x(\psi) &=& 
\left(
\begin{array}{ccc}
1 & 0 & 0 \\
0 & \cos \psi & -\sin \psi \\
0 & \sin \psi &  \cos \psi 
\end{array}
\right) \quad \mathrm{\text{Roll rotates around X}} 
\end{eqnarray}

\noindent thus, concatenating them in the proper order ($\mathbf{R}_x$, then $\mathbf{R}_y$, then $\mathbf{R}_z$)
we obtain the complete rotation matrix:

\begin{eqnarray}
\mathbf{R}(\phi,\chi,\psi) &=&  \mathbf{R}_z(\phi) \mathbf{R}_y(\chi) \mathbf{R}_x(\psi) 
\label{eq:mat_ypr} \\
&=& 
\left(
\begin{array}{ccc}
\cos \phi \cos \chi  & \cos \phi \sin \chi \sin \psi - \sin \phi \cos \psi   & \cos \phi \sin \chi \cos \psi + \sin \phi \sin \psi \\
\sin \phi \cos \chi  & \sin \phi \sin \chi \sin \psi + \cos \phi \cos \psi  &  \sin \phi \sin \chi \cos \psi - \cos \phi \sin \psi \\
-\sin \chi & \cos \chi \sin \psi  &  \cos \chi \cos \psi
\end{array}
\right) \nonumber
\end{eqnarray}

A transformation matrix $\mathbf{P}$ is always well-defined and does not suffer of degenerate cases, but its large
storage requirements ($4\times 4=16$ elements) makes more advisable to use other representations such 
as 3D+YPR (3+3=6 elements) or 3D+Quat (3+4=7 elements) in many situations. 
An important exception is the case when computation time is critical and the most common operation 
is composing (or inverse composing) a pose with a 3D point, where matrices require about half the 
computation time than the other methods. On the other hand, composing a pose with another pose is 
a slightly more efficient operation to carry out with a 3D+Quat representation. 

In any case, when dealing with uncertainties, transformation matrices are not a 
reasonable choice due to the 
quadratic cost of keeping their covariance matrices. 
The most common representation of a 6D pose with uncertainty in the literature 
are 3D+Quat forms (e.g. see \cite{davison2007mrt}), thus 
we will not describe how to 
obtain covariance matrices of a transformation matrix here.


\subsubsection{Implementation in MRPT}

The transformation matrix of any yaw-pitch-roll-based 6D pose stored in a 
\texttt{CPose3D} class can be obtained as follows:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::math; 
using namespace mrpt::poses; 

CMatrixDouble44  M;
CPose3D          p;
p.getHomogeneousMatrix(M);
\end{lstlisting}


\section{3D+Quat to matrix }
\label{sect:quat2mat}

\subsection{Transformation}

The transformation matrix associated to a 6D pose given as a 3D translation plus 
a quaternion is simply given by:

\begin{equation}
\mathbf{P}(x,y,z,q_r,q_x,q_y,q_z)=\left(
  \begin{array}{ccc|c}
   q_r^2+q_x^2-q_y^2-q_z^2 	&  2(q_x q_y - q_r q_z)	&  	2(q_z q_x+q_r q_y)  & x \\
   2(q_x q_y+q_r q_z) 		& q_r^2-q_x^2+q_y^2-q_z^2 	& 2(q_y q_z-q_r q_x) 	& y \\
   2(q_z q_x-q_r q_y) & 2(q_y q_z+q_r q_x)  & q_r^2- q_x^2 - q_y^2 + q_z^2 & z \\ \hline
   0 & 0 & 0& 1
  \end{array}
\right)
\end{equation}



\subsubsection{Implementation in MRPT}

In this case the interface of \texttt{CPose3DQuat} is exactly identical to that 
of the yaw-pitch-roll form, that is:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::math; 
using namespace mrpt::poses; 

CMatrixDouble44  M;
CPose3DQuat      p;
p.getHomogeneousMatrix(M);
\end{lstlisting}




%% ------------------
\section{Matrix to 3D+YPR   }
\label{sect:mat2ypr}

\subsection{Transformation}

If we consider the $4 \times 4$ transformation matrix for 
a 6D pose in 3D+YPR form (see Eq.~(\ref{eq:matP_ypr}) and (\ref{eq:mat_ypr})):

\begin{equation*}
\begin{array}{l}
\mathbf{P}(x,y,z,\phi,\chi,\psi)  \\
=\left(
  \begin{array}{ccc|c}
   \cos \phi \cos \chi  & \cos \phi \sin \chi \sin \psi - \sin \phi \cos \psi   & \cos \phi \sin \chi \cos \psi + \sin \phi \sin \psi & x \\
   \sin \phi \cos \chi  & \sin \phi \sin \chi \sin \psi + \cos \phi \cos \psi  &  \sin \phi \sin \chi \cos \psi - \cos \phi \sin \psi & y \\
   -\sin \chi & \cos \chi \sin \psi  &  \cos \chi \cos \psi & z \\ \hline
   0 & 0 & 0& 1
  \end{array}
\right) \\
=\left(
  \begin{array}{ccc|c}
   p_{11} & p_{12}& p_{13}& p_{14} \\
   p_{21} & p_{22}& p_{23}& p_{24} \\
   p_{31} & p_{32}& p_{33}& p_{34} \\
   0 & 0 & 0& 1
  \end{array}
\right)
\end{array}
\end{equation*}

\noindent it is obvious that the 3D translation part can be recovered by simply:

\begin{eqnarray*}
 \left\{
  \begin{array}{rcl}
    x &=& p_{14} \\
    y &=& p_{24} \\
    z &=& p_{34} 
  \end{array}
  \right.
\end{eqnarray*}

Regarding the three angles yaw ($\phi$), pitch ($\chi$) and roll ($\chi$), they must be obtained 
in two steps in order to properly handle the special cases 
(refer to the gimbal lock problem in \S \ref{sect:ypr:gimbal}).
Firstly, pitch is obtained from:

\begin{eqnarray}
  \chi &=& \mathrm{atan2} \left( -p_{31} , \sqrt{ p_{11}^2 + p_{21}^2 } \right) 
\end{eqnarray}

Next, depending on whether we are in a degenerate case ($|\chi|=90^\circ$) or 
not ($|\chi| \neq 90^\circ$), the following expressions must
be applied\footnote{At this point, special thanks go to 
Pablo Moreno Olalla for his work deriving robust expressions from Eq.~(\ref{eq:mat_ypr}) 
that work for all the special cases.}:

\begin{eqnarray}
  \chi = -90^\circ \quad \longrightarrow \quad
   \left\{
  \begin{array}{rcl}
    \phi  &=& \mathrm{atan2}( -p_{23}, -p_{13} ) \\
    \psi  &=& 0 \\
  \end{array}
   \right. 
\\
  |\chi| \neq 90^\circ \quad \longrightarrow \quad
   \left\{
  \begin{array}{rcl}
    \phi   &=& \mathrm{atan2}(p_{21},p_{11}) \\
    \psi  &=&  \mathrm{atan2}(p_{32},p_{33}) \\
  \end{array}
   \right. 
\\
  \chi = 90^\circ \quad \longrightarrow \quad
   \left\{
  \begin{array}{rcl}
    \phi  &=& \mathrm{atan2}( p_{23}, p_{13} ) \\
    \psi  &=& 0 \\
  \end{array}
   \right. 
\end{eqnarray}



\subsubsection{Implementation in MRPT}

Given a matrix \texttt{M}, the \texttt{CPose3D} representation can be obtained via
an explicit transform constructor:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::math; 
using namespace mrpt::poses; 

CMatrixDouble44  M;
...
CPose3D          p = CPose3D(M);
\end{lstlisting}


\section{Matrix to 3D+Quat }

\subsection{Transformation}

A numerically stable method to convert a $3 \times 3$ rotation matrix into a quaternion is
described in \cite{bar2000new}, which includes creating a temporary $4 \times 4$ matrix and 
computing the eigenvector corresponding to its largest eigenvalue. 
However, an alternative, more efficient method which can be applied if we are sure about 
the matrix being orthonormal is to simply convert it firstly to a yaw-pitch-roll representation 
(see \S \ref{sect:mat2ypr}) and then convert it 
to a quaternion representation (see \S \ref{sect:ypr2quat}).

 
\subsubsection{Implementation in MRPT}

Given a matrix \texttt{M}, the \texttt{CPose3DQuat} representation can be obtained via
an explicit transform constructor:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::math; 
using namespace mrpt::poses; 

CMatrixDouble44  M;
...
CPose3DQuat      p = CPose3DQuat(M);
\end{lstlisting}





%% ================================================
\chapter{Composing a pose and a point}

This chapter reviews how to compute the global coordinates of a point $\mathbf{a}$
given a pose $\mathbf{p}$ and the point coordinates relative to that coordinate system $\mathbf{a'}$,
as illustrated in Figure~\ref{fig:1}, that is, the pose chaining $\mathbf{a} = \mathbf{p} \oplus \mathbf{a'}$.

\section{With poses in 3D+YPR form}

\subsection{Composition}

In this case the solution is to firstly compute the $4 \times 4$ 
transformation matrix of the pose using Eq.~\ref{eq:mat_ypr}, then proceed 
as described in \S \ref{sect:comp_point:mat}.


\subsubsection{Implementation in MRPT}

A pose-point composition can be evaluated by means of:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 
using namespace mrpt::math; 

CPose3D   q;
TPoint3D  in_p, out_p;
...
q.composePoint(in_p, out_p);
\end{lstlisting}


\subsection{Uncertainty}

\cite{sibley2009rba}

XXX


\subsubsection{Implementation in MRPT}

There is not a direct method to implement a pose-point composition with uncertainty, 
but the two required Jacobians can be obtained from the method \texttt{composePoint()}:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 
using namespace mrpt::math; 

CPose3D  q;
CMatrixFixedNumeric<double,3,3>  df_dpoint;
CMatrixFixedNumeric<double,3,6>  df_dpose;
q.composePoint(lx,ly,lz,gx,gy,gz, &df_dpoint, &df_dpose);
\end{lstlisting}



\section{With poses in 3D+Quat form}

\subsection{Composition}

Given a pose described as $\mathbf{p_7} = [x ~ y ~ z ~  q_r ~ q_x ~ q_y ~ q_z ] ^ \top$, 
we are interested in the coordinates of $\mathbf{a}=[a_x ~ a_y ~ a_z]^\top$ such as
$\mathbf{a} = \mathbf{p_7} \oplus \mathbf{a'}$ for some known input point 
$\mathbf{a'} = [a'_x ~ a'_y ~ a'_z]^\top$. 
The solution is given by:

\begin{equation}
\mathbf{a} = \mathbf{f_{qr}} (\mathbf{p},\mathbf{a'})
\end{equation}

\noindent where the function $\mathbf{f_{qr}}(\cdot)$ is defined as:

\begin{equation}
\mathbf{f_{qr}} (\mathbf{p},\mathbf{a'}) = 
 \left(
\begin{array}{c}
 x + a'_x + 2 \left[-(q_y^2+ q_z^2) a'_x +(q_x q_y - q_r q_z) a'_y+(q_r q_y+q_x q_z) a'_z \right]  \\
 y + a'_y + 2 \left[(q_r q_z+  q_x q_y) a'_x-(q_x^2 +q_z^2) a'_y+(q_y q_z-q_r q_x) a'_z \right] \\
 z + a'_z + 2 \left[(q_x q_z-  q_r q_y) a'_x+(q_r q_x + q_y q_z) a'_y-(q_x^2+q_y^2) a'_z \right]  \\
\end{array}
\right)
\label{eq:quat_rot_point_func}
\end{equation}

\subsubsection{Implementation in MRPT}

A pose-point composition can be evaluated by means of:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 
using namespace mrpt::math; 

CPose3DQuat  q;
TPoint3D     in_p, out_p;
...
q.composePoint(in_p, out_p);
\end{lstlisting}


\subsection{Uncertainty}

Given a Gaussian distribution over a 7D pose in quaternion form with 
mean ${\mathbf{\bar{p}_7}}$ and being $cov(\mathbf{p_7})$ its $7 \times 7$ covariance matrix, 
and being ${\mathbf{\bar{a'}}}$ and $cov(\mathbf{a'})$ the mean and covariance of the 3D point 
$\mathbf{a'}$, respectively, the approximated covariance of the transformed point 
$\mathbf{a} = \mathbf{p_7} \oplus \mathbf{a'}$ is given by:

\begin{equation}
cov(\mathbf{a}) =
\frac{\partial \mathbf{f_{qr}} (\mathbf{p},\mathbf{a})}{\partial \mathbf{p}} ~
cov(\mathbf{p_7})  ~
\frac{\partial \mathbf{f_{qr}} (\mathbf{p},\mathbf{a})}{\partial \mathbf{p}}^\top 
+
\frac{\partial \mathbf{f_{qr}} (\mathbf{p},\mathbf{a})}{\partial \mathbf{a}} ~ 
cov(\mathbf{a'})  ~
\frac{\partial \mathbf{f_{qr}} (\mathbf{p},\mathbf{a})}{\partial \mathbf{a}}^\top
\end{equation}


The Jacobian matrices are:

\small{
\begin{equation}
 \begin{array}{l}
\left. 
\frac{\partial \mathbf{f_{qr}} (\mathbf{p},\mathbf{a})}{\partial \mathbf{p}} 
\right|_{3 \times 7} = 
  \left(
  \begin{array}{cccc}
    1  & 0 & 0 & ~ \\ 
    0  & 1 & 0 & \frac{\partial \mathbf{f_{qr}} (\mathbf{p},\mathbf{a})}{\partial [qr ~ qx ~ qy ~ qz]}  \\
    0  & 0 & 1 & ~ \\    
  \end{array}
  \right)
 \end{array}
\label{eq:quat_rot_point_func_jacob1}
\end{equation}

\noindent with the auxiliary term $\frac{\partial \mathbf{f_{qr}} (\mathbf{p},\mathbf{a})}{\partial [qr ~ qx ~ qy ~ qz]} $ 
including the normalization Jacobian (see \S \ref{sect:quat:norm}):

\begin{eqnarray}
\frac{\partial \mathbf{f_{qr}} (\mathbf{p},\mathbf{a})}{\partial [qr ~ qx ~ qy ~ qz]} 
  &=& 
  2
  \left(
  \begin{array}{ccccccc}
    -q_z a_y +q_y a_z   & q_y a_y + q_z a_z   &   -2q_y a_x + q_x a_y +q_r a_z & -2q_z a_x - q_r a_y +q_x a_z \\ 
    q_z a_x - q_x a_z   & q_y a_x - 2q_x a_y -q_r a_z  & q_x a_x +q_z a_z   & q_r a_x - 2 q_z a_y +q_y a_z \\
    -q_y a_x + q_x a_y  & q_z a_x + q_r a_y - 2q_x a_z  & -q_r a_x + q_z a_y - 2 q_y a_z  & q_x a_x + q_y a_y \\    
  \end{array}
  \right)
   \nonumber \\
  & \times  &
\frac{\partial (q_r',q_x',q_y',q_z')(q_r,q_x,q_y,q_z)}{\partial q_r,q_x,q_y,q_z} 
\end{eqnarray}

The other Jacobian is given by:

\begin{equation}
 \begin{array}{l}
\left. 
\frac{\partial \mathbf{f_{qr}} (\mathbf{p},\mathbf{a})}{\partial \mathbf{a}}
\right|_{3 \times 3} = 
  2
  \left(
  \begin{array}{ccc}
    \frac{1}{2}-q_y^2-q_z^2   & q_x q_y - q_r q_z   & q_r q_y + q_x q_z \\
    q_r q_z + q_x q_y  & \frac{1}{2} - q_x^2-q_z^2  & q_y q_z - q_r q_x \\
    q_x q_z - q_r q_y  & q_r q_x + q_y q_z & \frac{1}{2} - q_x^2-q_y^2
  \end{array}
  \right) 
\label{eq:quat_rot_point_func_jacob2}
 \end{array}
\end{equation}
}


\subsubsection{Implementation in MRPT}

There is not a direct method to implement a pose-point composition with uncertainty, 
but the two required Jacobians can be obtained from the method \texttt{composePoint()}:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 
using namespace mrpt::math; 

CPose3DQuat  q;
CMatrixFixedNumeric<double,3,3>  df_dpoint;
CMatrixFixedNumeric<double,3,7>  df_dpose;
q.composePoint(lx,ly,lz,gx,gy,gz, &df_dpoint, &df_dpose);
\end{lstlisting}



\section{With poses in matrix form}
\label{sect:comp_point:mat}

Given a $4\times 4$ transformation matrix $\mathbf{M}$ corresponding to a 6D pose 
$\mathbf{p}$ and a point in local coordinates 
$\mathbf{a'} = [a'_x ~ a'_y ~ a'_z]$, the corresponding point in global coordinates
$\mathbf{a} = [a_x ~ a_y ~ a_z]$ can be computed easily as:

\begin{eqnarray}
\mathbf{a} &=& \mathbf{p} \oplus \mathbf{a'} \nonumber \\
\left(\begin{array}{c}
 a_x \\ a_y \\ a_z \\ 1
\end{array}\right)
&=&
\mathbf{M} 
\left(\begin{array}{c}
 a'_x \\ a'_y \\ a'_z \\ 1
\end{array}\right)
\end{eqnarray}

\noindent where homogeneous coordinates (the column matrices) have been used for the 3D points.




%% ================================================
\chapter{Points relative to a pose}

In the next sections we will review how to compute the relative coordinates 
of a point $\mathbf{a'}$ given a pose $\mathbf{p}$ and the point global coordinates
$\mathbf{a}$,
as illustrated in Figure~\ref{fig:1}, that is, $\mathbf{a'} = \mathbf{a} \ominus \mathbf{p}$.

\section{With poses in 3D+YPR form}

\subsection{Inverse transformation}

The relative coordinates of a point with respect to a pose in this parameterization can be computed
by first obtaining the matrix form of the pose \S\ref{sect:ypr2mat}, then using it as described in \S\ref{sect:inv_comp_mat}.



\subsubsection{Implementation in MRPT}

Given a 6D-pose as an object of type \texttt{CPose3D}, one can invoke its method 
\texttt{inverseComposePoint()} which, in one of its signatures, reads:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 
using namespace mrpt::math; 

CPose3D    q;
TPoint3D   in_p, out_p;
...
q.inverseComposePoint(in_p, out_p);
\end{lstlisting}


\subsection{Uncertainty}

In this case it's preferred to transform the 3D pose to a 3D+Quat, then
perform the transformation as described in the following section.



\section{With poses in 3D+Quat form}
\label{sect:point_inv:quat}

\subsection{Inverse transformation}

Given a 7D-pose $\mathbf{p_7}=[x ~ y ~ z ~ qr ~ qx ~ qy ~ qz]^\top$ and a point in 
global coordinates $\mathbf{a} = [a_x ~ a_y ~ a_z]^\top$, the point coordinates 
relative to $\mathbf{p_7}$, that is, $\mathbf{a'} = \mathbf{a} \ominus \mathbf{p_7}$, are given by:


\begin{eqnarray}
\label{eq:fqri}
\mathbf{a'} = \mathbf{f_{qri}}( \mathbf{a}, \mathbf{p_7} ) =
\left(\begin{array}{c}
%-
 (a_x-x) + 2 \left[-(q_y^2+ q_z^2) (a_x-x) +(q_x q_y - q_r q_z) (a_y-y)+(q_r q_y+q_x q_z) (a_z-z) \right]  \\
 (a_y-y) + 2 \left[(q_r q_z+  q_x q_y) (a_x-x)-(q_x^2 +q_z^2) (a_y-y)+(q_y q_z-q_r q_x) (a_z-z) \right] \\
 (a_z-z) + 2 \left[(q_x q_z-  q_r q_y) (a_x-x)+(q_r q_x + q_y q_z) (a_y-y)-(q_x^2+q_y^2) (a_z-z) \right]  \\
%-
\end{array}\right) 
\end{eqnarray}


\subsubsection{Implementation in MRPT}

Given a 7D-pose as an object of type \texttt{CPose3DQuat}, one can invoke its method 
\texttt{inverseComposePoint()} which, in one of its signatures, reads:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 
using namespace mrpt::math; 

CPose3DQuat  q;
TPoint3D     in_p, out_p;
...
q.inverseComposePoint(in_p, out_p);
\end{lstlisting}


\subsection{Uncertainty}

Given a Gaussian distribution over a 7D pose in 3D+Quar form with 
mean $\mathbf{\bar{p}_7}$ and being $cov(\mathbf{p_7})$ its $7 \times 7$ covariance matrix,
and assuming that a 3D point follows an (independent) Gaussian distribution 
with mean $\mathbf{\bar{a}}$ and $3 \times 3$ covariance $cov(\mathbf{a})$, 
we can estimate the covariance of the transformed local point $\mathbf{a'}$ 
as:

\begin{equation}
cov(\mathbf{a'}) =
\frac{\partial \mathbf{f_{qri}}( \mathbf{a}, \mathbf{p} )}{\partial \mathbf{p_7}}
cov(\mathbf{p_7})  ~
\frac{\partial \mathbf{f_{qri}}( \mathbf{a}, \mathbf{p} )}{\partial \mathbf{p_7}}^\top 
+
\frac{\partial \mathbf{f_{qri}}( \mathbf{a}, \mathbf{p} )}{\partial \mathbf{a}}
cov(\mathbf{a})  ~
\frac{\partial \mathbf{f_{qri}}( \mathbf{a}, \mathbf{p} )}{\partial \mathbf{a}}^\top 
\end{equation}

\noindent where the Jacobian matrices are given by:

\begin{eqnarray}
\frac{ \partial \mathbf{f_{qri}}( \mathbf{a}, \mathbf{p} )}{\partial \mathbf{a}} = 
\left(\begin{array}{ccc} 
1 - 2 (q_y^2 + q_z^2)   &    2 q_x q_y + 2 qr q_z  &     - 2 qr q_y + 2 q_x q_z \\
-2 qr q_z + 2 q_x q_y &   1 - 2 (q_x^2 + q_z^2) &   2 q_y q_z + 2 qr q_x \\
2 q_x q_z + 2 qr q_y &   -2 qr q_x + 2 q_y q_z & 1 - 2 (q_x^2 + q_y^2 ) \\
\end{array}\right) 
\end{eqnarray}

\noindent and, if we define 
$\Delta x = (a_x - x)$, $\Delta y = (a_x - x)$ and $\Delta z = (a_z - z)$, we can 
write the Jacobian with respect to the pose as:

\begin{eqnarray}
\label{eq:df_qri_p}
\frac{ \partial \mathbf{f_{qri}}( \mathbf{a}, \mathbf{p} )}{\partial \mathbf{p}} = 
\left(\begin{array}{ccc|c} 
2 q_y^2 + 2 q_z^2 - 1 &   -2 q_r q_z - 2 q_x q_y &  2 q_r q_y - 2 q_x q_z &  ~ 
\\
2 q_r q_z - 2 q_x q_y &  2 q_x^2 + 2 q_z^2 - 1   &  -2 q_r q_x - 2 q_y q_z &  
  \frac{ \partial \mathbf{f_{qrir}}( \mathbf{a}, \mathbf{p} )}{\partial \mathbf{p}}
\\
-2 q_r q_y - 2 q_x q_z &  2 q_r q_x - 2 q_y q_z &  2 q_x^2 + 2 q_y^2 - 1 & ~
\\
\end{array}\right) 
\end{eqnarray}

\noindent with:

\begin{eqnarray}
\frac{ \partial \mathbf{f_{qrir}}( \mathbf{a}, \mathbf{p} )}{\partial \mathbf{p}} 
&=& 
\left(\begin{array}{cccc} 
2 q_y \Delta z - 2 q_z \Delta y &                  2 q_y \Delta y + 2 q_z \Delta z & 
2 q_x \Delta y - 4 q_y \Delta x + 2 qr \Delta z &  2 q_x \Delta z - 2 qr \Delta y - 4 q_z \Delta x 
\\
 2 q_z \Delta x - 2 q_x \Delta z &  2 q_y \Delta x - 4 q_x \Delta y - 2 q_r \Delta z &         
2 q_x \Delta x + 2 q_z \Delta z &  2 q_r \Delta x - 4 q_z \Delta y + 2 q_y \Delta z
\\
 2 q_x \Delta y - 2 q_y \Delta x &  2 q_z \Delta x + 2 qr \Delta y - 4 q_x \Delta z & 
2 q_z \Delta y - 2 qr \Delta x - 4 q_y \Delta z &  2 q_x \Delta x + 2 q_y \Delta y
\\
\end{array}\right) \nonumber \\
& ~ & \cdot \frac{\partial (q_r',q_x',q_y',q_z')(q_r,q_x,q_y,q_z)}{\partial q_r,q_x,q_y,q_z}  
\end{eqnarray}

\noindent where the second term in the product is the Jacobian of the quaternion 
normalization (see \S \ref{sect:quat:norm}).



\subsubsection{Implementation in MRPT}

As in the previous case, here we it can be also employed the method 
\texttt{inverseComposePoint()} which if provided the optional output parameters,
will return the desired Jacobians:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 
using namespace mrpt::math; 

CPose3DQuat  q;
TPoint3D     g, l;
CMatrixFixedNumeric<double,3,3>  dfi_dpoint;
CMatrixFixedNumeric<double,3,7>  dfi_dpose;
...
q.inverseComposePoint(
  g.x,g.y,g.z, // Input  (global coords) 
  l.x,l.y,l.z, // Output (local coords)
  &dfi_dpoint, // 3x3 Jacobian
  &dfi_dpose   // 3x7 Jacobian
  );
\end{lstlisting}



\section{With poses as matrices}
\label{sect:inv_comp_mat}

Given a $4\times 4$ transformation matrix $\mathbf{M}$ corresponding to a 6D pose 
$\mathbf{p}$ and a point in global coordinates 
$\mathbf{a} = [a_x ~ a_y ~ a_z]$, the corresponding point in local coordinates
$\mathbf{a'} = [a'_x ~ a'_y ~ a'_z]$ is given by:

\begin{eqnarray}
\mathbf{a'} &=& \mathbf{a} \ominus \mathbf{p} \nonumber \\
\left(\begin{array}{c}
 a'_x \\ a'_y \\ a'_z \\ 1
\end{array}\right)
&=&
\mathbf{M}^{-1} 
\left(\begin{array}{c}
 a_x \\ a_y \\ a_z \\ 1
\end{array}\right)
\end{eqnarray}

\noindent where homogeneous coordinates (the column matrices) have been used for the 3D points.
An efficient way to compute the inverse of a homogeneous matrix is 
described in \S \ref{sect:inverse:mat}


\section{Relation with pose-point direct composition}

% Regarding the inverse composition operation, such as in
% $\mathbf{a'} = \mathbf{a} \ominus \mathbf{p}$ as 
% described in the example of \S \ref{sect:basic}, 
There is an interesting result that naturally arises from the matrix form 
explained in the previous section.
By definition, we have:

\begin{eqnarray}
 \mathbf{a} = \mathbf{p} \oplus \mathbf{a'}   
\leftrightarrow
 \mathbf{a'} = \mathbf{a} \ominus \mathbf{p}
\label{eq:comp_invcomp}
\end{eqnarray}

Then, starting with $\mathbf{a} = \mathbf{p} \oplus \mathbf{a'}$
and using the matrix form, we can proceed as follows:

\begin{eqnarray*}
 \mathbf{a} &=& \mathbf{p} \oplus \mathbf{a'}    \\
 \mathbf{A} &=& \mathbf{P}  \mathbf{A'}  \quad \text{(Representation as matrices)}  \\
 \mathbf{P}^{-1} \mathbf{A} &=& \mathbf{P}^{-1} \mathbf{P}  \mathbf{A'} \\
 \mathbf{P}^{-1} \mathbf{A} &=& \mathbf{A'}  \\
 (\ominus \mathbf{p}) \oplus \mathbf{a} &=& \mathbf{a'}  \quad \text{(Back to $\oplus$/$\ominus$ notation)} \\
 (\ominus \mathbf{p}) \oplus \mathbf{a} &=& \mathbf{a} \ominus \mathbf{p}  \quad \text{(Using Eq.~\ref{eq:comp_invcomp})}
\end{eqnarray*}

\noindent where $(\ominus \mathbf{p})$ stands for the inverse of a pose $\mathbf{p}$. 
Thus, the result is that any inverse pose composition can be transformed into a normal 
pose composition, by switching the order of the two arguments
($\mathbf{a}$ and $\mathbf{p}$ in this case) and inverting the latter.
Note that the inverse of a pose is a topic discussed in \S \ref{sect:inverse}.


%% ================================================
\chapter{Composition of two poses}

Next sections are devoted to computing the composed pose $\mathbf{p}$ resulting
from a concatenation of two 6D poses $\mathbf{p_1}$ and $\mathbf{p_2}$, 
that is, $\mathbf{p} = \mathbf{p_1} \oplus \mathbf{p_2}$. 
An example of this operation was shown in Figure~\ref{fig:comp_2poses}.

\section{With poses in 3D+YPR form}

\subsection{Pose composition}

There is not simple
equation for pose composition for poses described as triplets 
of yaw-pitch-roll angles, thus it is recommended to transform them into 
either 3D+Quad or matrix form 
(see, \S \ref{sect:ypr2quat} and \S \ref{sect:ypr2mat}, respectively), 
then compose them as described in the following sections and finally
convert the result back into 3D+YPR form.

\subsubsection{Implementation in MRPT}

Pose composition for 3D+YPR poses is implemented via overloading 
of the ``\texttt{+}'' C++ operator 
(using matrix representation to perform the intermediary computations), 
such as composing can be simply 
writen down as:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3D  p1,p2; 
...
CPose3D  p = p1 + p2;    // Pose composition
\end{lstlisting}

\subsection{Uncertainty}

Given a Gaussian distribution over a 6D pose in yaw-pitch-roll form with 
mean ${\mathbf{\bar{p}_6}}$ and being  $cov(\mathbf{p_6})$ its $6 \times 6$ covariance matrix, 
the $7 \times 7$ covariance matrix of the equivalent quaternion-based form 
is approximated by:

XXX

\subsubsection{Implementation in MRPT}

The composition is easily performed via an overloaded ``+'' operator, as can be seen in this code:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3DPDFGaussian p6a( p6_mean_a, p6_cov_a ); 
CPose3DPDFGaussian p6b( p6_mean_b, p6_cov_b ); 
...

CPose3DPDFGaussian p6 = p6a + p6b; // Pose composition (both mean and covariance)
\end{lstlisting}




\section{With poses in 3D+Quat form}

\subsection{Pose composition}

Given two poses 
$\mathbf{p_1} = [x_1 ~ y_1 ~ z_1 ~  q_{r1} ~ q_{x1} ~ q_{y1} ~ q_{z1} ] ^ \top$
and 
$\mathbf{p_2} = [x_2 ~ y_2 ~ z_2 ~  q_{r2} ~ q_{x2} ~ q_{y2} ~ q_{z2} ] ^ \top$, 
we are interested in their composition $\mathbf{p}=\mathbf{p_1} \oplus \mathbf{p_2}$.

Operating, this pose can be found to be:

\begin{equation}
\mathbf{p} = 
\left(\begin{array}{c}
 x \\ y \\ z \\ q_r \\ q_x \\ q_y \\ q_z      
\end{array}\right)
= \mathbf{f_{qn}}\left(  \mathbf{f_{qc}}(\mathbf{p_1},\mathbf{p_2}) \right)
=
\mathbf{f_{qn}}
\left(\begin{array}{c}
  \mathbf{f_{qr}} (\mathbf{p_1}, [ x_2 ~ y_2 ~ z_2]^\top ) \\
q_{r1} q_{r2} - q_{x1} q_{x2} - q_{y1} q_{y2} - q_{z1} q_{z2} \\
q_{r1} q_{x2} + q_{r2} q_{x1} + q_{y1} q_{z2} - q_{y2} q_{z1} \\
q_{r1} q_{y2} + q_{r2} q_{y1} + q_{z1} q_{x2} - q_{z2} q_{x1} \\
q_{r1} q_{z2} + q_{r2} q_{z1} + q_{x1} q_{y2} - q_{x2} q_{y1}
\end{array}\right)
\end{equation}

\noindent with the function $\mathbf{f_{qr}}(\cdot)$ already defined in Eq.~\ref{eq:quat_rot_point_func}
and $\mathbf{f_{qn}}$ being the quaternion normalization function, discussed in 
\S \ref{sect:quat:norm}.


\subsubsection{Implementation in MRPT}

Pose composition for 3D+Quat poses is implemented via overloading 
of the ``\texttt{+}'' operator, such as composing can be simply 
writen down as:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3DQuat  p1,p2; 
...
CPose3DQuat  p = p1 + p2;    // Pose composition
\end{lstlisting}


\subsection{Uncertainty}

Let $\mathcal{N}(\mathbf{\bar{p}_1}, cov(\mathbf{p_1}))$ and 
$\mathcal{N}(\mathbf{\bar{p}_2}, cov(\mathbf{p_2}))$ represent
two independent Gaussian distributions over a pair of 6D 
poses in quaternion form.
Then, the probability distribution of their composition 
$\mathbf{p} = \mathbf{p_1} \oplus \mathbf{p_2}$
can be approximated via linear error propagation by considering 
a mean value of:

\begin{eqnarray}
\mathbf{\bar{p}} = \mathbf{\bar{p}_1} \oplus \mathbf{\bar{p}_2}
\end{eqnarray}

\noindent and a covariance matrix given by:

\begin{eqnarray}
cov(\mathbf{\bar{p}}) &=& 
\frac{\partial \mathbf{f_{qn}} }{\partial \mathbf{p}}
\frac{\partial \mathbf{f_{qc}}(\mathbf{p_1},\mathbf{p_2}) }{\partial \mathbf{p_1}}
cov(\mathbf{p_1})
\frac{\partial \mathbf{f_{qc}}(\mathbf{p_1},\mathbf{p_2}) }{\partial \mathbf{p_1}}^\top
\frac{\partial \mathbf{f_{qn}} }{\partial \mathbf{p}} ^\top
\nonumber \\ &+&
\frac{\partial \mathbf{f_{qn}} }{\partial \mathbf{p}}
\frac{\partial \mathbf{f_{qc}}(\mathbf{p_1},\mathbf{p_2}) }{\partial \mathbf{p_2}}
cov(\mathbf{p_2})
\frac{\partial \mathbf{f_{qc}}(\mathbf{p_1},\mathbf{p_2}) }{\partial \mathbf{p_2}}^\top
\frac{\partial \mathbf{f_{qn}} }{\partial \mathbf{p}}^\top
\end{eqnarray}

The Jacobians of the pose composition function $\mathbf{f_{qc}}(\cdot)$ are given by:


\begin{eqnarray}
\left. 
\frac{\partial \mathbf{f_{qc}}(\mathbf{p_1},\mathbf{p_2}) }{\partial \mathbf{p_1}} 
\right|_{7 \times 7} 
= 
\left(
  \begin{array}{c}
     \left. \frac{\partial \mathbf{f_{qr}} (\mathbf{p_1}, [ x_2 ~ y_2 ~ z_2]^\top ) }{\partial \mathbf{p_1}} \right|_{3\times 7} \\ \hline
  \begin{array}{ccccccc}
    &  &  			& q_{r2} &-q_{x2} &-q_{y2} &-q_{z2}  \\
    & & \mathbf{0}_{4\times 3}  	& q_{x2} & q_{r2} & q_{z2} &-q_{y2}  \\
    & &  			& q_{y2} &-q_{z2} & q_{r2} & q_{x2}  \\
    & &  			& q_{z2} & q_{y2} &-q_{x2} & q_{r2}   
  \end{array}
  \end{array}
\right) 
\\
\left. 
\frac{\partial \mathbf{f_{qc}}(\mathbf{p_1},\mathbf{p_2}) }{\partial \mathbf{p_2}} 
\right|_{7 \times 7} 
= 
\left(
  \begin{array}{ccc|cccc}
     & \left. 
	\frac{\partial \mathbf{f_{qr}} (\mathbf{p_1}, [ x_2 ~ y_2 ~ z_2]^\top ) }{\partial [ x_2 ~ y_2 ~ z_2]^\top} \right|_{3\times 3} 
      &  & & \mathbf{0}_{3 \times 4}  \\ \hline
   & & 				& q_{r1} &-q_{x1} &-q_{y1} &-q_{z1}  \\
   & \mathbf{0}_{4\times 3} &	& q_{x1} & q_{r1} &-q_{z1} & q_{y1}  \\
   & & 				& q_{y1} & q_{z1} & q_{r1} &-q_{x1}  \\
   & & 				& q_{z1} &-q_{y1} & q_{x1} & q_{r1}   
  \end{array}
\right)
\end{eqnarray}


Note that the partial Jacobians used in these expressions were already defined 
in Eq.~(\ref{eq:quat_rot_point_func_jacob1})-(\ref{eq:quat_rot_point_func_jacob2}),
and that the Jacobian of the normalization function $\mathbf{f_{qn}}$ is described
in \S \ref{sect:quat:norm}.



\subsubsection{Implementation in MRPT}

The composition is easily performed via an overloaded ``+'' operator:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3DQuatPDFGaussian     p7a( p7_mean_a, p7_cov_a ); 
CPose3DQuatPDFGaussian     p7b( p7_mean_b, p7_cov_b ); 
...

CPose3DQuatPDFGaussian p7 = p7a + p7b; // Pose composition (both mean and covariance)
\end{lstlisting}




\section{With poses in matrix form}
\label{sect:comp_poses:mat}

\subsection{Pose composition}

Given a pair of $4\times 4$ transformation matrices 
$\mathbf{M_1}$ and $\mathbf{M_2}$ corresponding to two 6D poses
$\mathbf{p_1}$ and $\mathbf{p_2}$, we can compute the 
matrix $\mathbf{M}$ for their composition $\mathbf{p} = \mathbf{p_1} \oplus \mathbf{p_2}$ 
simply as:

\begin{equation}
\mathbf{M} =  \mathbf{M_1}  \mathbf{M_2}
\end{equation}

\subsubsection{Implementation in MRPT}

In this case, operate just like with ordinary matrices:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CMatrixDouble44  M1, M2;
...
CMatrixDouble44  M = M1 * M2;  // Matrix multiplication
\end{lstlisting}



%% ================================================
\chapter{Inverse of a pose}
\label{sect:inverse}

Given a pose $\mathbf{p}$, we define its \emph{inverse} 
(denoted as $\ominus \mathbf{p}$) 
as that pose that, composed with the former, gives the null element 
in $\mathbf{SE}(3)$. 
In practice, it is useful to visualize the inverse of a pose as 
how the origin of coordinates ''is seen'', from that pose.


% ---------------
\section{For a 3D+YPR pose}

In this case it's preferred to transform the 3D pose to either a 3D+Quat or a matrix form, 
invert the pose in that form (as described in the next sections) and convert back to 3D+YPR.


\subsubsection{Implementation in MRPT}

Obtaining the inverse of a 6D-pose of type \texttt{CPose3D} is implemented 
with the unary \texttt{-} operator which internally uses the cached $4 \times 4$ 
transformation matrix within \texttt{CPose3D} objects:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3D   q;
CPose3D   q_inv = -q;
\end{lstlisting}




% ---------------
\section{For a 3D+Quat pose}
\label{sect:inverse:quat}

\subsection{Inverse}

The inverse of a pose $\mathbf{p_7} = [x ~ y ~ z ~  q_r ~ q_x ~ q_y ~ q_z ] ^ \top$
comprises two parts which can be computed separately.
If we denote this inverse as $\mathbf{p^\star_7} = [x^\star ~ y^\star ~ z^\star ~  q^\star_r ~ q^\star_x ~ q^\star_y ~ q^\star_z ] ^ \top$,
its rotational part is simply the conjugate quaternion of the original pose, while the 3D translational
part must be computed as the relative position of the origin $[0 ~ 0 ~ 0]^\top$ as seen 
from the pose $\mathbf{p_7}$, that is:

\begin{eqnarray}
\mathbf{p^\star_7} = 
\left(
\begin{array}{c}
x^\star \\ y^\star \\ z^\star \\  q^\star_r \\ q^\star_x \\ q^\star_y \\ q^\star_z
\end{array}
\right) 
= 
\mathbf{f_{qi}}( \mathbf{p_7} ) 
=
\left(
\begin{array}{c}
\mathbf{f_{qri}}( [0 ~ 0 ~ 0]^\top, \mathbf{p_7} ) 
\\  q_r \\ -q_x \\ -q_y \\ -q_z
\end{array}
\right)
\end{eqnarray}

\noindent where $\mathbf{f_{qri}}(\mathbf{a},\mathbf{p})$  was defined in Eq.~(\ref{eq:fqri}).



\subsubsection{Implementation in MRPT}

Obtaining the inverse of a 7D-pose of type \texttt{CPose3DQuat} is implemented 
with the unary \texttt{-} operator:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3DQuat   q;
CPose3DQuat   q_inv = -q;
\end{lstlisting}


\subsection{Uncertainty}

Let $\mathcal{N}(\mathbf{\bar{q}}, cov(\mathbf{q}))$ represent
the Gaussian distributions of a 7D-pose $\mathbf{q}$ in 3D+Quat form. 
Then, the probability distribution of the inverse pose 
$\mathbf{q_i} = \ominus \mathbf{q_i} $ can be approximated via 
linear error propagation by considering a mean value of:

\begin{eqnarray}
\mathbf{\bar{q}_i} = \ominus \mathbf{\bar{q}}
\end{eqnarray}

\noindent and a covariance matrix:

\begin{eqnarray}
cov(\mathbf{q_i}) &=& 
\frac{\partial \mathbf{f_{qi}} }{\partial \mathbf{q}}
cov(\mathbf{q})
\frac{\partial \mathbf{f_{qi}} }{\partial \mathbf{q}} ^\top
\end{eqnarray}

\noindent with the Jacobian:

\begin{eqnarray}
\frac{\partial \mathbf{f_{qi}} }{\partial \mathbf{q}}
= 
\left(
\begin{array}{c}
\frac{\partial \mathbf{f_{qri}}([0~0~0]^\top,\mathbf{q}) }{\partial \mathbf{q}} \\ 
\hline 
 \begin{array}{c|c}
   \mathbf{0}_{4 \times 4} & 
   \begin{array}{rrrr}
    1 & 0 & 0 & 0 \\
    0 & -1 & 0 & 0 \\
    0 & 0 & -1 & 0 \\
    0 & 0 & 0 & -1 
   \end{array}
 \end{array}
\end{array}
\right)
\end{eqnarray}

\noindent where the sub-Jacobian on the top has been already defined in Eq.(\ref{eq:df_qri_p}).



\subsubsection{Implementation in MRPT}

The Gaussian distrution of an inverse 3D+Quat pose can be computed simply by:

\begin{lstlisting}
#include <mrpt/base.h> 
using namespace mrpt::poses; 

CPose3DQuatPDFGaussian  p1 = ...
CPose3DQuatPDFGaussian  p1_inv = -p1;
\end{lstlisting}



% ---------------
\section{For a transformation matrix}
\label{sect:inverse:mat}

From the description of inverse pose at the begining of this chapter, and given
that the null element in $\mathbf{SE}(3)$ in matrix form is the identity $\mathbf{I}_4$, 
it's clear that the inverse of pose defined by a matrix $\mathbf{M}$ is simply $\mathbf{M}^{-1}$, 
since $\mathbf{M}^{-1}\mathbf{M}=\mathbf{I}$.

The inverse of a homogeneous matrix can be computed very efficiently by 
simply transposing its $3 \times 3$ rotation part (which actually requires \emph{just 3 swaps}) 
and using the following expressions for the fourth column (the translation):

\begin{eqnarray}
M^{-1} &=& 
\left(
  \begin{array}{ccc|c}
   \mathbf{i} & \mathbf{j} & \mathbf{k} & \mathbf{t} \\
\hline
   0 & 0 & 0 & 1
  \end{array}
\right) ^{-1} 
= 
\left(
  \begin{array}{ccc|c}
   i_1 & j_1 & k_1 & x \\
   i_2 & j_2 & k_2 & y \\
   i_3 & j_3 & k_3 & z \\
\hline
   0 & 0 & 0 & 1
  \end{array}
\right) ^{-1} 
= 
\left(
  \begin{array}{ccc|c}
   i_1 & i_2 & i_3   & -\mathbf{i} \cdot \mathbf{t} \\ 
   j_1 & j_2 & j_3   & -\mathbf{j} \cdot \mathbf{t} \\ 
   k_1 & k_2 & k_3   & -\mathbf{k} \cdot \mathbf{t} \\ 
\hline
   0 & 0 & 0 & 1
  \end{array}
\right)
\end{eqnarray}

\noindent where $\mathbf{a} \cdot \mathbf{b}$ stands for the dot product.


%% ================================================
\chapter{Lie algebra of $\mathbf{SE}(3)$}
\label{sect:se3_lie}

Since $\mathbf{SE}(3)$ is a Lie group, there exists a logarithm function that maps a group
element into its tangent-space 6D vector, with the inverse operation being the exponential map 
\cite{eade2008phd,gallier2001geometric}.

XXX



%% ---------------------------------------------------------------
%%                         BIBLIOGRAPHY
%% ---------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{/Trabajo/Papers/myReferences}


\end{document}

